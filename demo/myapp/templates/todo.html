{% extends 'base.html' %}
{% load static %}

{% block extra_head %}
<!-- Add Tailwind CSS CDN -->
<script src="https://cdn.tailwindcss.com"></script>

<!-- Mapbox Scripts -->
<script src='https://api.mapbox.com/mapbox-gl-js/v3.10.0/mapbox-gl.js'></script>
<link href='https://api.mapbox.com/mapbox-gl-js/v3.10.0/mapbox-gl.css' rel='stylesheet' />
<!-- Mapbox Search JS -->
<script id="search-js" defer src="https://api.mapbox.com/search-js/v1.0.0/web.js"></script>
<script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
<style>
  /* Ensure the search box is visible and properly styled */
  mapbox-search-box {
    display: block;
    width: 100%;
    margin-bottom: 0.75rem;
  }
  
  /* Style the internal input element */
  mapbox-search-box::part(input) {
    width: 100%;
    padding: 0.5rem 0.75rem;
    border-radius: 0.25rem;
    border: 1px solid #cbd5e0;
    box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1);
  }
</style>
{% endblock %}

{% block content %}
<div class="container mx-auto px-4 py-8">
    <!-- Todo Form -->
    <form method="POST" action="{% url 'add_todo' %}" class="mb-8 bg-white shadow-md rounded px-8 pt-6 pb-8">
        {% csrf_token %}
        <div class="mb-4">
            <label class="block text-gray-700 text-sm font-bold mb-2">Title</label>
            <input type="text" name="title" required class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700">
        </div>
        <div class="mb-4">
            <label class="block text-gray-700 text-sm font-bold mb-2">Description</label>
            <textarea name="description" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700"></textarea>
        </div>
        <!-- Location Fields -->
        <div class="mb-4">
            <label class="block text-gray-700 text-sm font-bold mb-2">Location</label>
            <mapbox-search-box id="search-box" access-token="{{ mapbox_token }}" class="mb-3"></mapbox-search-box>
            <div id="map" class="w-full aspect-[16/9] rounded-lg overflow-hidden shadow-md"></div>
            <input type="text" id="location_name" name="location_name" class="mt-3 shadow appearance-none border rounded w-full py-2 px-3 text-gray-700" placeholder="Location name" readonly>
            <input type="hidden" id="latitude" name="latitude">
            <input type="hidden" id="longitude" name="longitude">
        </div>
        <div class="flex justify-end">
            <button type="submit" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">Add Todo</button>
        </div>
    </form>

    <!-- Todo List -->
    <div class="bg-white shadow-md rounded px-8 pt-6 pb-8">
        <h2 class="text-2xl font-bold mb-4">Your Todos</h2>
        {% for todo in todos %}
        <div class="flex items-center justify-between border-b py-4">
            <div class="flex-1 cursor-pointer" onclick="showTodoDetails('{{ todo.id }}', '{{ todo.title }}', '{{ todo.description }}', '{{ todo.location_name }}', '{{ todo.latitude }}', '{{ todo.longitude }}')">
                <h3 class="text-lg font-semibold {% if todo.completed %}line-through text-gray-500{% endif %}">
                    {{ todo.title }}
                </h3>
                {% if todo.description %}
                <p class="text-gray-600">{{ todo.description }}</p>
                {% endif %}
                {% if todo.location_name %}
                <p class="text-sm text-gray-500">üìç {{ todo.location_name }}</p>
                {% endif %}
            </div>
            <div class="flex space-x-2">
                <form method="POST" action="{% url 'toggle_todo' todo.id %}">
                    {% csrf_token %}
                    <button type="submit" class="bg-green-500 hover:bg-green-700 text-white font-bold py-1 px-2 rounded">
                        {% if todo.completed %}Undo{% else %}Complete{% endif %}
                    </button>
                </form>
                <form method="POST" action="{% url 'delete_todo' todo.id %}">
                    {% csrf_token %}
                    <button type="submit" class="bg-red-500 hover:bg-red-700 text-white font-bold py-1 px-2 rounded">
                        Delete
                    </button>
                </form>
            </div>
        </div>
        {% endfor %}
    </div>
</div>

<!-- Todo Details Modal -->
<div id="todoModal" class="fixed inset-0 bg-gray-600 bg-opacity-50 hidden overflow-y-auto h-full w-full z-50">
    <div class="relative top-20 mx-auto p-5 border w-full max-w-2xl shadow-lg rounded-md bg-white">
        <div class="mt-3">
            <h3 id="modalTitle" class="text-2xl font-bold leading-6 text-gray-900 mb-2"></h3>
            <p id="modalDescription" class="text-gray-600 mb-4"></p>
            <div id="modalLocation" class="text-sm text-gray-500 mb-2"></div>
            <div id="detailMap" class="w-full aspect-[16/9] rounded-lg overflow-hidden shadow-md mb-4"></div>
            <div class="flex justify-end">
                <button onclick="closeModal()" class="bg-gray-500 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded">
                    Close
                </button>
            </div>
        </div>
    </div>
</div>

<script>
mapboxgl.accessToken = '{{ mapbox_token }}';

// Generate a UUID for session token
function generateUUID() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
    });
}

// Create a session token for the search session
const sessionToken = generateUUID();

// Initialize the map
const map = new mapboxgl.Map({
    container: 'map',
    style: 'mapbox://styles/mapbox/streets-v12',
    center: [151.2500, -33.9189], // Default: UNSW
    zoom: 14,
    attributionControl: true
});

// Add navigation controls
map.addControl(new mapboxgl.NavigationControl(), 'top-right');

// Store the current marker reference
let currentMarker = null;

// Wait for the Mapbox Search JS script to load
document.getElementById('search-js').onload = function() {
    console.log('Search JS loaded');
    
    // Get the search box element that's already in the DOM
    const searchBox = document.getElementById('search-box');
    
    if (!searchBox) {
        console.error('Search box element not found');
        return;
    }
    
    console.log('Search box element found:', searchBox);
    
    try {
        // Set the session token for billing purposes
        searchBox.sessionToken = sessionToken;
        
        // Configure the search box with options from the API documentation
        searchBox.options = {
            country: 'au',
            language: 'en',
            types: 'address,poi,place',
            bbox: [149.9719, -34.3209, 151.6438, -33.4461], // Sydney area
            proximity: [151.2500, -33.9189], // UNSW coordinates
            limit: 10,
            fuzzyMatch: true,
            autocomplete: true
        };
        
        console.log('Search box options set');

        // Bind the search box to the map for better integration
        searchBox.mapboxgl = mapboxgl;
        
        // Handle selection from search box
        searchBox.addEventListener('retrieve', (event) => {
            console.log('Retrieve event triggered');
            const response = event.detail;
            
            // Log the entire response for debugging
            console.log('Raw response data:', response);
            
            if (!response) {
                console.warn('No response in retrieve event');
                return;
            }

            try {
                // Handle both single Feature and FeatureCollection responses
                let feature;
                
                // Check if we have a FeatureCollection
                if (response.type === 'FeatureCollection' && response.features && response.features.length > 0) {
                    console.log('Received a FeatureCollection with', response.features.length, 'features');
                    // Use the first feature from the collection
                    feature = response.features[0];
                } else {
                    // Assume it's a single feature
                    feature = response;
                }
                
                console.log('Processing feature:', feature);
                
                if (!feature) {
                    console.warn('No valid feature found in response');
                    alert('No valid location data found. Please try a different search.');
                    return;
                }

                // First, check if we have a feature.feature_type to determine the response format
                console.log('Feature type:', feature.feature_type);
                console.log('Feature properties:', feature.properties);
                
                // Extract coordinates based on the Mapbox Search Box API structure
                let coordinates;
                
                // For Mapbox Search Box API, coordinates are typically in feature.coordinates
                if (feature.coordinates) {
                    if (feature.coordinates.longitude !== undefined && feature.coordinates.latitude !== undefined) {
                        coordinates = [feature.coordinates.longitude, feature.coordinates.latitude];
                        console.log('Found coordinates in feature.coordinates object:', coordinates);
                    } else if (Array.isArray(feature.coordinates)) {
                        coordinates = feature.coordinates;
                        console.log('Found coordinates in feature.coordinates array:', coordinates);
                    }
                }
                
                // Check for routable_points which is sometimes used in the Search Box API
                if (!coordinates && feature.coordinates && feature.coordinates.routable_points && 
                    feature.coordinates.routable_points.length > 0) {
                    const point = feature.coordinates.routable_points[0];
                    coordinates = [point.longitude, point.latitude];
                    console.log('Found coordinates in routable_points:', coordinates);
                }
                
                // Check for standard GeoJSON format
                if (!coordinates && feature.geometry && feature.geometry.coordinates) {
                    coordinates = feature.geometry.coordinates;
                    console.log('Found coordinates in geometry.coordinates:', coordinates);
                }
                
                // Check for center property
                if (!coordinates && feature.center) {
                    coordinates = feature.center;
                    console.log('Found coordinates in center property:', coordinates);
                }
                
                // Check for bbox center as last resort
                if (!coordinates && feature.bbox) {
                    // Calculate center of bounding box
                    const bbox = feature.bbox;
                    const lng = (bbox[0] + bbox[2]) / 2;
                    const lat = (bbox[1] + bbox[3]) / 2;
                    coordinates = [lng, lat];
                    console.log('Calculated coordinates from bbox:', coordinates);
                }
                
                if (!coordinates) {
                    console.error('Could not find coordinates in feature:', feature);
                    alert('Could not find coordinates for the selected location. Please try a different location.');
                    return;
                }
                
                console.log('Final extracted coordinates:', coordinates);

                // Extract location name with multiple fallbacks
                let locationName = '';
                
                // Try various paths to find a proper name based on the Search Box API structure
                if (feature.name) {
                    locationName = feature.name;
                } else if (feature.place_name) {
                    locationName = feature.place_name;
                } else if (feature.properties) {
                    if (feature.properties.name) {
                        locationName = feature.properties.name;
                    } else if (feature.properties.full_address) {
                        locationName = feature.properties.full_address;
                    } else if (feature.properties.address) {
                        locationName = feature.properties.address;
                    } else if (feature.properties.place_name) {
                        locationName = feature.properties.place_name;
                    }
                } else if (feature.text) {
                    locationName = feature.text;
                }
                
                if (!locationName) {
                    locationName = `Selected Location (${coordinates[1].toFixed(6)}, ${coordinates[0].toFixed(6)})`;
                }
                
                console.log('Extracted location name:', locationName);
                
                // Set form values
                document.getElementById('location_name').value = locationName;
                document.getElementById('latitude').value = coordinates[1];  // latitude is the second element
                document.getElementById('longitude').value = coordinates[0]; // longitude is the first element
                
                // Remove existing marker if exists
                if (currentMarker) {
                    currentMarker.remove();
                }
                
                // Remove existing popups
                document.querySelectorAll('.mapboxgl-popup').forEach(popup => popup.remove());

                // Add marker with animation
                currentMarker = new mapboxgl.Marker({ 
                    draggable: true,
                    color: '#3FB1CE' // Bright blue for visibility
                })
                    .setLngLat(coordinates)
                    .addTo(map);

                // Fly to location with animation
                map.flyTo({
                    center: coordinates,
                    zoom: 16,
                    essential: true,
                    duration: 1500 // Animation duration in milliseconds
                });
                
                console.log('Map centered on coordinates:', coordinates);

                // Drag marker to update location
                currentMarker.on('dragend', function() {
                    const lngLat = currentMarker.getLngLat();
                    console.log('Marker dragged to:', lngLat);
                    
                    // Clear the search box when marker is dragged
                    const searchBox = document.getElementById('search-box');
                    if (searchBox) {
                        // Clear the search box input
                        searchBox.value = '';
                        
                        // If the search box has a clear method, call it
                        if (typeof searchBox.clear === 'function') {
                            searchBox.clear();
                        }
                    }
                    
                    reverseGeocode(lngLat.lng, lngLat.lat);
                });
            } catch (error) {
                console.error('Error processing search result:', error);
                console.error('Feature that caused error:', feature);
                alert('There was an error processing the selected location. Please try again.');
            }
        });

        // Also enhance the search box to ensure it's working
        searchBox.placeholder = 'Search for an address or landmark';

        // Add a debugging helper function
        function checkSearchBoxStatus() {
            const searchBox = document.getElementById('search-box');
            if (!searchBox) {
                console.error('Search box element not found - checkSearchBoxStatus');
                return;
            }
            
            console.log('Search box status:', {
                'Element': searchBox,
                'Has sessionToken': !!searchBox.sessionToken,
                'Has options': !!searchBox.options,
                'Has event listeners': searchBox._events || 'Unknown'
            });
        }

        // Check search box status after a short delay
        setTimeout(checkSearchBoxStatus, 2000);

        // Handle errors according to API documentation
        searchBox.addEventListener('error', (event) => {
            console.error('Search error:', event.detail);
            alert('There was an error with the search. Please try again.');
        });
        
        // Add suggestion event listener to debug
        searchBox.addEventListener('suggest', (event) => {
            console.log('Suggestion event:', event.detail);
        });
        
        console.log('Event listeners added');
    } catch (error) {
        console.error('Error initializing search box:', error);
    }
};

// Click on map to select location
map.on('click', function(e) {
    const lngLat = e.lngLat;
    const [lng, lat] = [lngLat.lng, lngLat.lat];

    // Update input fields
    document.getElementById('latitude').value = lat;
    document.getElementById('longitude').value = lng;

    // Clear the search box when clicking on the map
    const searchBox = document.getElementById('search-box');
    if (searchBox) {
        // Clear the search box input
        searchBox.value = '';
        
        // If the search box has a clear method, call it
        if (typeof searchBox.clear === 'function') {
            searchBox.clear();
        }
    }

    // Reverse geocode
    reverseGeocode(lng, lat);

    // Remove existing marker
    if (currentMarker) {
        currentMarker.remove();
    }

    // Add new marker
    currentMarker = new mapboxgl.Marker({ draggable: true })
        .setLngLat([lng, lat])
        .addTo(map);

    // Drag marker updates location
    currentMarker.on('dragend', function() {
        const lngLat = currentMarker.getLngLat();
        
        // Clear the search box when marker is dragged
        const searchBox = document.getElementById('search-box');
        if (searchBox) {
            // Clear the search box input
            searchBox.value = '';
            
            // If the search box has a clear method, call it
            if (typeof searchBox.clear === 'function') {
                searchBox.clear();
            }
        }
        
        reverseGeocode(lngLat.lng, lngLat.lat);
    });
});

// Reverse geocoding using the Search Box API's reverse endpoint
async function reverseGeocode(lng, lat) {
    try {
        // First try using the Mapbox Geocoding API which often provides better address results
        const geocodingResponse = await fetch(
            `https://api.mapbox.com/geocoding/v5/mapbox.places/${lng},${lat}.json?` +
            `access_token=${mapboxgl.accessToken}&` +
            `types=address,place,neighborhood,locality,district,postcode,region&` +
            `limit=1`
        );
        
        const geocodingData = await geocodingResponse.json();
        console.log("Primary geocoding response:", geocodingData);
        
        if (geocodingData.features && geocodingData.features.length > 0) {
            const feature = geocodingData.features[0];
            document.getElementById('location_name').value = feature.place_name;
            
            // Remove popup code since we don't want to show the address on the marker
            return; // Exit early if we got a good result
        }
        
        // If the first method didn't work, try the Search Box API's reverse endpoint
        const response = await fetch(
            `https://api.mapbox.com/search/searchbox/v1/reverse?` +
            `longitude=${lng}&latitude=${lat}&` +
            `access_token=${mapboxgl.accessToken}&` +
            `session_token=${sessionToken}&` +
            `limit=1&` +
            `language=en&` +
            `types=address,street,neighborhood,postcode,district,place,locality,region`
        );
        
        const data = await response.json();
        console.log("Search Box reverse geocode response:", data);
        
        if (data.features && data.features.length > 0) {
            const feature = data.features[0];
            // Handle the response format according to the API documentation
            let locationName = '';
            
            // Try to get the most detailed address information available
            if (feature.properties) {
                if (feature.properties.full_address) {
                    locationName = feature.properties.full_address;
                } else if (feature.properties.address) {
                    locationName = feature.properties.address;
                } else if (feature.properties.name) {
                    locationName = feature.properties.name;
                }
            }
            
            if (!locationName && feature.place_name) {
                locationName = feature.place_name;
            }
            
            // If we still don't have a location name, try one more geocoding method
            if (!locationName) {
                try {
                    const backupResponse = await fetch(
                        `https://api.mapbox.com/geocoding/v5/mapbox.places/${lng},${lat}.json?` +
                        `access_token=${mapboxgl.accessToken}&` +
                        `types=address,place,neighborhood,locality,district,postcode,region&` +
                        `limit=1`
                    );
                    
                    const backupData = await backupResponse.json();
                    console.log("Backup geocoding response:", backupData);
                    
                    if (backupData.features && backupData.features.length > 0) {
                        locationName = backupData.features[0].place_name;
                    }
                } catch (backupError) {
                    console.error("Backup geocoding failed:", backupError);
                }
            }
            
            // Last resort: use coordinates
            if (!locationName) {
                locationName = `Location at ${lat.toFixed(6)}, ${lng.toFixed(6)}`;
            }
            
            document.getElementById('location_name').value = locationName;
            
            // Remove popup code since we don't want to show the address on the marker
        } else {
            // Try one more geocoding method if Search Box API didn't return results
            try {
                const backupResponse = await fetch(
                    `https://api.mapbox.com/geocoding/v5/mapbox.places/${lng},${lat}.json?` +
                    `access_token=${mapboxgl.accessToken}&` +
                    `types=address,place,neighborhood,locality,district,postcode,region&` +
                    `limit=1`
                );
                
                const backupData = await backupResponse.json();
                console.log("Backup geocoding response:", backupData);
                
                if (backupData.features && backupData.features.length > 0) {
                    const locationName = backupData.features[0].place_name;
                    document.getElementById('location_name').value = locationName;
                    
                    // Remove popup code since we don't want to show the address on the marker
                } else {
                    // No features found in any API, fall back to coordinates
                    const locationName = `Location at ${lat.toFixed(6)}, ${lng.toFixed(6)}`;
                    document.getElementById('location_name').value = locationName;
                }
            } catch (backupError) {
                console.error("Backup geocoding failed:", backupError);
                // Last resort: use coordinates
                const locationName = `Location at ${lat.toFixed(6)}, ${lng.toFixed(6)}`;
                document.getElementById('location_name').value = locationName;
            }
        }
    } catch (error) {
        console.error("Error getting address:", error);
        // Last attempt with traditional geocoding
        try {
            const response = await fetch(
                `https://api.mapbox.com/geocoding/v5/mapbox.places/${lng},${lat}.json?` +
                `access_token=${mapboxgl.accessToken}&` +
                `types=address,place,neighborhood,locality,district,postcode,region&` +
                `limit=1`
            );
            
            const data = await response.json();
            console.log("Final fallback geocode response:", data);
            
            if (data.features && data.features.length > 0) {
                document.getElementById('location_name').value = data.features[0].place_name;
                
                // Remove popup code since we don't want to show the address on the marker
            } else {
                // If even the fallback doesn't work, use coordinates
                document.getElementById('location_name').value = `Location at ${lat.toFixed(6)}, ${lng.toFixed(6)}`;
            }
        } catch (fallbackError) {
            console.error("Fallback geocoding also failed:", fallbackError);
            // Last resort: just use the coordinates
            document.getElementById('location_name').value = `Location at ${lat.toFixed(6)}, ${lng.toFixed(6)}`;
        }
    }
}

let detailMap = null;

function showTodoDetails(id, title, description, location, lat, lng) {
    document.getElementById('modalTitle').textContent = title;
    document.getElementById('modalDescription').textContent = description || 'No description';
    document.getElementById('modalLocation').textContent = location ? `üìç ${location}` : 'No location set';
    document.getElementById('todoModal').classList.remove('hidden');
    document.getElementById('detailMap').style.display = lat && lng ? 'block' : 'none';

    // Initialize or update the detail map if a valid location exists
    if (lat && lng) {
        if (!detailMap) {
            detailMap = new mapboxgl.Map({
                container: 'detailMap',
                style: 'mapbox://styles/mapbox/streets-v12',
                center: [lng, lat],
                zoom: 14,
                attributionControl: true
            });
            detailMap.addControl(new mapboxgl.NavigationControl(), 'top-right');
        } else {
            detailMap.setCenter([lng, lat]);
            detailMap.setZoom(14);
        }

        // Remove any previous markers on the detail map and add a new one
        document.querySelectorAll('#detailMap .mapboxgl-marker').forEach(marker => marker.remove());
        new mapboxgl.Marker()
            .setLngLat([lng, lat])
            .addTo(detailMap);
    }
}

// Resize maps when the window is resized
window.addEventListener('resize', () => {
    map.resize();
    if (detailMap) {
        detailMap.resize();
    }
});

function closeModal() {
    document.getElementById('todoModal').classList.add('hidden');
}

// Close modal when clicking outside of it
window.onclick = function(event) {
    const modal = document.getElementById('todoModal');
    if (event.target == modal) {
        closeModal();
    }
}
</script>
{% endblock %}